Ну кароче, конспектик + планы + всякое

НИЖНИЙ УРОВЕНЬ: ЖЕЛЕЗЯКИ, ИНСТАНТЫ И ДРУГОЕ ГОВНО

Всё, до примерного окна будет исполнятся в классе hard_vulkan_level. 
1) Инстант. Самая база, начало нашего всего. Поскольку все объекты строятся по пути: заполни структуру -- создай на её базе объект, сначала создаём структуру для будущего вызова VkCreateInstance.
2) Физический девайс. Определяемся с его возможностями, сколько чего может и так далее. Примерный пак работ такой: 
    2.1) vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr), который даст нам число видеокарт
    2.2) Для подходящих устройств выделяем массив VkPhysicalDevice devices
    2.3) vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data()) -- второй вызов для уже записи количества в массив
    
    !!! СНОСКА !!!
    
    Двойной вызов в вулкане используется:
    При первом вызове для получения данных в первую переменную (чаще всего инт)
    При втором вызове вызываем с тем же интом, но в нуллптр уже вписываем указатель на массив
    В него запишутся уже сами данные
    
    !!! СНОСКА ВСЁ !!!
    
    2.4) Проверка на соответсвие нашим нуждам. Примерно тут можно использовать бальную систему как предлагают или 
    придумать что-нибудь умное, но это слишком умно, в помощь vkGetPhysicalDeviceFeatures(device, VkPhysicalDeviceFeatures)
    
3) Логическое устройство (тоже названый девайс, но логический). VkDevice. Тут описываются штуки, которые конкретно вы 
будете использовать, например 64-битовые числа-плавунцы.
4) Семейства очередей. VkQueue. Очереди выделяются из семейства очередей, где каждое семейство поддерживает определенный набор операций.
Например, для операций с графикой, вычислительных операций и передачи данных памяти могут существовать отдельные семейства очередей.
НАСТОЯТЕЛЬНО РЕКОМЕНДУЮТ ЗАВЕРНУТЬ ЭТУ ХУЕТУ В STD::OPTIONAL, ВЕДЬ ДАЖЕ ЗНАЧЕНИЕ 0 В ИНТЕ МОЖЕТ ЗНАЧИТ ПРИСУТСВИЕ НУЖНЫХ ОЧЕРЕДЕЙ

vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);
std::vector<VkQueueFamilyProperties> queueFamilies(queueFamilyCount);
vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data())

В самой-самой базе нужно хотя бы одно устройство с поддержкой VK_QUEUE_GRAPHICS_BIT
vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &graphicsQueue); -- вот эта хуета, подробнее будет когда будет реализация

Дальше идут штуки из middle_vulkan_level (они являются переходным этапом и связывают окна и подобную шелуху с будущим софт-левел вулканом и железным хард-левел вулканом)

1) Используем GLFW с поддержкой вулкана для окна
2) VkSurfaceKHR с привязкой к glfw окну, чтобы указать в какое собственно окно рендерим

    !!!   СНОСКА   !!!
    
    Из-за нужды некоторых функций в hard уровне, первые два параметра буду в виде одинаковых указателей содержатся в миддл уровне
    
    !!! СНОСКА ВСЁ !!!

3) VkSwapchainKHR -- Цепочка показа — это набор целей рендеринга. Ее задача — обеспечивать, чтобы изображение, которое рендерится в текущий момент, отличалось от отображаемого на экране.
4) Для рисования используется VkImageView b VkFramebuffer (последний выполняет вместе с первым функцию stencil-буффера и не только)
5) VkRenderPass -- информация о всевозможных буфферах -- цвет, глубина, вот это вот всё

soft_vulkan_level тут. Является обёрткой над службами, которые будут использоваться чаще всего и поэтому ДОЛЖЕН быть сделан 
развлетвлённее и удобнее.
1) Графический конвеер. VkPipeline. Придётся держать пул из них, из-за того, что только некоторые данные можно динамически
настраивать, при большинстве из них нужно пересоздавать пайплайн. 
2) VkShaderModule -- ясно. Эта часть тоже лежит внутри граф коневеера.
3) VkCommandPool и VkCommandBuffer -- команды для всего soft уровня. 
4) VkQueueSubmit -- Пусть просто тут лежит.

Пиздец, для базы нормально навалил

VBO есмь вбо, уже работали.
Для полноценной работы с шейдерами нам нужно пояснить по понятиям вулкану что да как надо обрабатывать. 
VkVertexInputBinding -- объект с прилагающейся description-структурой
VK_VERTEX_INPUT_RATE_VERTEX: переход к следующему элементу данных происходит после каждой вершины
VK_VERTEX_INPUT_RATE_INSTANCE: переход к следующему элементу данных происходит после каждого экземпляра




    